%---Include Befehle-------------------------------------------------------------------
\documentclass[a4paper]{article}
\usepackage{ngerman, amsmath, amssymb, bbm, array, tabularx}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc} 		% Kodierung
\usepackage[ngerman]{babel} 		% Sprache
\usepackage{textcomp}       		% Zusätzliche Symbolzeichen 
\setlength{\parskip}{1.5ex plus0.5ex minus0.2ex} 
\setlength{\parindent}{0cm}
\usepackage[]{graphicx}   			% initialisierung von Graphiken
\usepackage{xcolor}					% init von Farbe

%---Seitenränder einstellen-----------------------------------------------------------
\usepackage[left=30mm,right=25mm,top=25mm,bottom=25mm]{geometry}

%---Kopf- und Fusszeile---------------------------------------------------------------
\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyhf{}
\lhead{{\footnotesize HTW Berlin}} 				% linke Seite Kopfzeile, Größe wie eine Fußnote
\chead{} 										% Mitte Kopf - leer
\rhead{{\footnotesize SWE - Belegarbeit GIT}} 	% rechte Seite Kopfzeile
\lfoot{{\footnotesize F. Goerge, S. Ede,\\ R. Peters, J. Meise}} %linke Seite Fußnote
\cfoot{} 										% Mitte Fußnote leer
\rfoot{\thepage} 								% Rechte Fußnote Seitenzahl
\renewcommand{\headrulewidth}{0.2pt}    		% Größe Kopf/Fußzeile?
\renewcommand{\footrulewidth}{0.2pt}

%---Glossar---------------------------------------------------------------------------
\usepackage[urlcolor=blue,colorlinks=true,linkcolor=blue]{hyperref} %Farbe der Links in blau
\usepackage[toc,style=treenoname,order=word,subentrycounter]{glossaries} 
\makeglossaries

%---Glossareinträge-------------------------------------------------------------------
%Glossar update Info. -> Benutzer/in -> Eigene Befehle -> Eigene Befehle editieren
% --> makeindex -s %.ist -t %.glg -o %.gls %.glo
% und unter -> Option -> Texmaker konfigurieren -> Makeindex Verweis aktualisieren!

\newglossaryentry{merge}		{name=Merge		,description={engl. zusammenführen, Vereinigung von Branches}}
\newglossaryentry{Repository}	{name=Repository,description={dt. Lager, Depot, Repositorium. enthält die Geschichte eines Projekts. Jeder Nutzer hat ein eigenes Repository mit der gesamten Geschichte}}
\newglossaryentry{Clone} 		{name=Clone		,description={engl. kopieren}}
\newglossaryentry{Branch}		{name=Branch	,description={engl. Zweig. Ein Entwicklungszweig in der Geschichte}}
\newglossaryentry{Switch}		{name=Switch	,description={engl. wechseln}}
\newglossaryentry{Pull}			{name=Pull		,description={engl. ziehen. Lädt Objekte und Branches. Lädt somit alle Änderungen}}
\newglossaryentry{fetch}		{name=Fetch		,description={engl. holen, holt Brachnes von fernen? Repositories}}
\newglossaryentry{Commit}		{name=Commit	,description={engl. übergeben - Mit diesem Befehl werden lokale Änderungen im lokalen Repository gespeichert. }}
\newglossaryentry{Pointer}		{name=Pointer	,description={engl. Zeiger, Verweis auf ein existierendes Objekt}}
\newglossaryentry{Changeset}		{name=Changeset	,description={mehrere Änderungen zu einer Einheit zusammengefasst}}
\newglossaryentry{Head}		{name=Head	,description={engl. Kopf, Verweis auf die aktuelle Änderung. Neue Änderungen werden hinter dem Head gespeichert.}}
%-------------------------------------------------------------------------------------

\begin{document}

%---Deckblatt-------------------------------------------------------------------------
\title{\textbf{{\Huge { Belegarbeit GIT \vspace{2cm}} 
\includegraphics[width=\textwidth]{git-logo.png}	% einfügen von Bildern
\vspace{2cm} }}}
\author{Fabian Goerge \\  Sami Ede  \\ Richard Peters \\ Jens Meise}
\date{\today}
\maketitle
\thispagestyle{empty} 								% Keine Seitenzahl auf dem Deckblatt 

%------------------------------------------------------------------------------------

\newpage

%---Inhaltsverzeichnis wird erzeugt--------------------------------------------------
\setcounter{page}{1} 								% Inhaltsverzeichnis startet mit der Seitenzahl 1 
\tableofcontents									% Inhaltsverzeichnis wird erzeugt

%------------------------------------------------------------------------------------

\newpage

\textcolor{red}
{
	FERTIGSTELLUNG BIS 09.12.!!!!!!!!!!! 
	und wehe nicht!!!!!!!!!!!!!\\
	- PDF vollenden (gemeinsame Punkte bearbeiten)\\
	- Präsentation fertigstellen (16.12. / 22.12.)
}
%---Erster Punkt--------------------------------------------------------------------
\section{\underline{Einführung und Ziel der Arbeit}} 	% Section erstellt automatisch den jeweiligen Punkt. Das erste Section erstellt Punkt 1, das 2te Punkt 1 etc.

\subsection{Einführung} 								% Subsection erstellt automatisch Unterpunkte

%Beispiel für einen Glossar Eintrag....der oben noch definiert werden muss!
%"...mit einem \gls{merge} kann man" gls = glossary entry; in den Klammern der vordefinierte Glossareintrag

	% textbigfat
Git ist ein freies Versionsverwaltungssystem, dass von Linus Torvald entwickelt wurde.
(Das zu der Zeit existierende Versionsverwaltungssystem BitKeeper war aus Lizenzgründen nicht mehr für das Linuxentwicklerteam zugänglich, und so entschied sich Torvald dafür, ein eigenes System zu schreiben.) \\
Ein Versionsverwaltungssystem verfolgt Änderungen in Dokumenten oder Dateien und speichert die durch die Änderungen entstehenden Versionen in einem Verzeichnis so ab, dass sie mit einem Zeitstempel und einer Benuzerkennung versehen werden und später wieder hergestellt werden können. Git bietet weiterhin die Möglichkeit sich eigene \gls{Branch}es zu erstellen, so dass man unabhängig vom "Hauptstrang" arbeiten kann, um so zum Beispiel Portierungen einer Applikation auf andere Betriebssysteme zu entwickeln. \\
Git speichert außerdem alle Dateien lokal, so dass auch ohne Internetverbindung gearbeitet werden kann, die Zusammenführung (\gls{merge}) der Branches muss dann zu einem späteren Zeitpunkt stattfinden. Jeder Benutzer verfügt also über eine komplette Kopie des \gls{Repository}. \\
Die Speicherung der Versionsgeschichte erfolgt so, dass der Name einer beliebigen Revision auf der vollständigen Geschichte basiert, die zu dieser Version geführt hat, so dass es nicht möglich ist, die Versionsgeschichte nachträglich zu ändern. Diese Funktion ermöglicht auch, bestimmte Versionen gesondert digital zu signieren, um z.B. den Zustand zum Zeitpunkt des Erscheinens einer neuen Version besonders zu kennzeichnen. \\
Ein weiterer Vorteil von Git ist zudem eine große Vielfalt von Möglichkeiten zum Austausch zwischen Repositories; Git unterstützt eine Vielzahl von Protokollen zum Dateiaustausch, darunter auch ein eigenes, sehr effizientes (git://).\\


\subsection{Ziel}
	Das Ziel dieses Projektes, ist die Modellierung von Git, die Darstellung und Rekonstruktion einer Software über Diagramme, sowie die Auseinandersetzung mit den verschiedenen Modellierungsarten. \\
	Dafür werden wir uns zunächst mit einem Use-Case-Modell beschäftigen und dieses anschließend in einigen Use-Case-Szenarien elaborieren. \\
	Außerdem wird ein Domänenmodell dargestellt, sowie einige ausgewählte Zustandsdiagramme.\\
	Abschließend erläutern wir einige Erfahrungen aus der Teamarbeit und eine Schlussbetrachtung.
\newpage												% Seitenumbruch
\section{\underline{Textuelle Beschreibung}}

Git ist eine freie Software zur verteilten Versionsverwaltung von Dateien. Git hilft, wenn mehrere Programmierer an einem Projekt arbeiten, indem es verschiedene Features vereint:

  \begin{itemize} 										% Aufzählungen
     
\item Git ermöglicht eine nicht-lineare Entwicklung; das heißt, es ist möglich, an verschiedenen „Positionen“ des Quelltextes zu arbeiten, und diese im Nachhinein automatisch zu vereinen („mergen“). %Jeder Backslash ist ein Bulletpoint
\item des Weiteren bietet Git die Möglichkeit eines lokalen Arbeitens. Jeder User besitzt eine lokale Kopie des kompletten Repositories (inklusive der Versionsgeschichte), so dass auch ohne Anbindung in ein Netzwerk gearbeitet werden kann. Dies ermöglicht sehr schnelles Arbeiten!
Dies bedeutet auch gleichzeitig Multi-Backups! Jeder User speichert die komplette Versionsgeschichte!
\item Mehrere Möglichkeiten, Repositories abzugleichen; Git besitzt ein eigenes Protokoll, und unterstützt unter anderem http, https, ftp und rsync Übertragungen.
\item Versionsgeschichte wird kryptografisch gesichert, so dass es nicht möglich ist, Änderungen an der Versionsgeschichte vorzunehmen, ohne dass sich der Name der Revision ändert.

    \end{itemize} 										% Aufzählung beendet

Außerdem bietet Git ein Webinterface.

\section{\underline{Modellierung}}

\subsection{Use-Case-Modell}

\includegraphics[width=\textwidth]{Use-Case-Modell.png}	

Dieses Use-Cases repräsentieren die Interaktion zwischen dem Programmierer (\textit{Aktor}) und dem Git-System (\textit{Subjekt})\\  							% Textit = Textitalian = kursiv
\\ 														% Absatz
Der Programmierer benutzt das Git-System um ein bestimmtes Ziel zu erreichen. 
Der Git-Server (\textit{Sekundäre Aktor}) wird von dem Git-System genutzt um eine Auswahl von Befehlen ausführen zu können.\\
\\
Der Programmierer repräsentiert eine Personengruppe. An einem Projekt können beliebig viele Programmierer beteiligt seien.  
Der Admin erbt alle Fähigkeiten von dem Programmierer. Demnach kann der Admin auch alle anderen Interaktionen ausüben.  \\
\\
Im Use-Case sind die Möglichkeiten, Verwalte \gls{Repository}, Verwalte Rechte, \gls{Clone} Reopisitory, Bearbeite Quellecode, Erstelle \gls{Branch}, \gls{merge} Branch und \gls{Switch} Branch aufgeführt. \\
\\
Eine detaillierte Beschreibung der Abläufe folgt in den Use-Case-Szenarien. 

\newpage	
\subsubsection{Use-Case-Szenarien (Storys)}

	- Happy day Szenarien und Optionale Verzweigungen (Abweichungen vom Happy Day) (Richard)
	
\textbf{GIT   Use – Case Szenarien}

\textbf{Use Case: 			Clone Repository}\\
Kurzbeschreibung: 	Der Programmierer kopiert sämtliche Daten des Repositories auf seinen lokalen Rechner.\\
Vorbedingung:	Ein Repository muss auf dem Server existieren\\
Primärer Aktor:	Programmierer\\
Nachbedingung:	Das Repository auf dem Rechner des Programmierers ist mit dem auf dem Server identisch\\
Erfolgsszenario:\\
\\
Der Programmierer gibt das Kommando zum Klonen eines Repositories mit Serveradresse in die Shell ein. Das System verbindet sich mit dem Server. Das System überträgt das Repository vom Server auf den Rechner des Programmierers. Das System informiert den Programmierer über den Erfolg der Aktion. Das Use Case endet erfolgreich.\\
\\

\textbf{Use Case: 			Quellcode bearbeiten}\\
Kurzbeschreibung: 	Der Programmierer möchte den Quellcode ändern. Dazu muss er das Repositorie auf den neuesten Stand bringen (‚pull‘), den Quellcode bearbeiten, die Änderungen übernehmen (‚commit‘) und die Änderungen an den Server übertragen (‚Push‘)\\
Vorbedingung:	Ein Repository muss sich auf dem Rechner und auf dem Server befinden.\\
Primärer Aktor:	Programmierer\\
Nachbedingung:	Die Änderungen des Programmierers werden registriert und in die History aufgenommen.\\
Erfolgsszenario:\\
\\
Der Programmierer gibt das Kommando zum Holen von Änderungen in die Shell ein. Das System verbindet sich mit dem Server. Das System vergleicht den lokalen Zustand des Branches mit dem auf dem Server.
Das System integriert (‚\gls{merge}‘) den Branch auf dem Server in den Branch auf dem Rechner. Das System informiert den Programmierer über den Erfolg der Aktion. Der Programmierer ändert den Quellcode
Das System verfolgt die Änderungen. Der Programmierer gibt das Kommando zum Übernehmen (‚Commit‘) von Änderungen in die Shell ein mit einer Kurzbeschreibung seiner Änderungen. Das System übernimmt die Änderungen und trägt sie in die History des aktuellen Branches ein. Das System informiert den Programmierer über den Erfolg der Aktion. Der Programmierer gibt das Kommando zum Übertragen der Änderungen (‚Pull‘) auf den Server ein. Das System integriert den aktuellen Branch des Rechners in den entsprechenden Branch auf dem Server (‚\gls{merge}‘) Das System liefert dem Programmierer eine Erfolgsmeldung. Das Use Case endet erfolgreich.\\
\\
\textbf{Use Case: 			Branch erstellen}\\
Kurzbeschreibung: 	Das System erstellt einen neuen Branch mit dem Zustand des Branches auf dem sich der Programmierer befindet.\\
Vorbedingung:	Es muss ein Repository existieren.\\
Primärer Aktor:	Programmierer\\
Nachbedingung:	Es gibt einen neuen Branch.\\
Erfolgsszenario:\\
\\
Der Programmierer gibt das Kommando zum Erstellen eines Branches in die Shell ein mit dem Namen des neuen Branches. Das System erzeugt einen neuen Branch. Das Use Case endet erfolgreich.\\
\\
\textbf{Use Case: 			Branch mergen}\\
Kurzbeschreibung: 	Ein Branch wird in einen anderen Branch integriert\\
Vorbedingung:	Es müssen 2 Branches existieren.\\
Primärer Aktor:	Programmierer\\
Nachbedingung:	Es gibt einen neuen Branch.\\
Erfolgsszenario:\\
\\
Der Programmierer gibt das Kommando zum Mergen eines Branches in die Shell ein mit dem Namen des zu integrierenden Branches. Das System integriert den Branche in den aktiven Branche. Das Use Case endet erfolgreich.\\
\\
\textbf{Use Case: 			Branch switchen}\\
Kurzbeschreibung: 	Der aktuelle Branch auf dem Rechner wird gewechselt (‚switch‘)\\
Vorbedingung:	Es müssen mindestens 2 Branches existieren.\\
Primärer Aktor:	Programmierer\\
Nachbedingung:	Der aktuelle Branch wurde gewechselt.\\
Erfolgsszenario:\\
\\
Der Programmierer gibt das Kommando zum Wechseln eines Branches (‚switch‘) in die Shell ein mit dem Namen des Zielbranches. Das System wechselt zum Zielbranch.Das Use Case endet erfolgreich.\\
\\
\textbf{Use Case: 			Repository verwalten}\\
Kurzbeschreibung: 	Ein Repository wird verwaltet.\\
Vorbedingung:	Keine – es kann auch erst bei der Verwaltung ein Repository angelegt werden.\\
Primärer Aktor:	Admin\\
Nachbedingung:	Repository verändert. \\
Erfolgsszenario:\\
\\
Der Admin spezifiziert eine Verwaltungsoperation (löschen, erstellen umbenennen). Das System führt die entsprechende Aktion aus und informiert den Admin über den Erfolg der Aktion. Das Use Case endet erfolgreich.\\
\\
\textbf{Use Case: 			Rechte verwalten}\\
Kurzbeschreibung: 	Der Admin kann Leserechte und ausführrecht für bestimmte Nutzergruppen verteilen.\\
Vorbedingung:	Es muss mindestens eine Gruppe bestehen. \\
Primärer Aktor:	Admin\\
Nachbedingung:	Die Rechte wurden geändert. \\
Erfolgsszenario:\\
\\
Der Admin gibt das Kommando zum Verwalten von Rechten in die Shell ein mit dem Namen der zu verwaltenden Gruppe. Das System listet die Rechte der ausgewählten Gruppe. Der Admin gibt entsprechende Kommandos zum Verwalten der Rechte ein. Das System informiert den Admin über eine erfolgreiche Ausführung der Aktion. Das Use Case endet erfolgreich.\\
\\

Repository: Die Projektdaten und Informationen des Git-Systems (History, Branches, etc).
\newpage	
\subsection{Domänenmodell}

\includegraphics[width=\textwidth]{Domaenenmodell.jpg}\\
Die Abbildung stellt das Domänenmodell der Software GIT dar.\\\\

Das \gls{Repository} ist die Hauptklasse unseres Modells. Es kann ein Repository auf einem Server existieren, von dem beliebig viele lokale Repositories geklont werden können (siehe Clone Repository - Zustandsdiagramm). Zu jedem Repository gehören mindestens ein oder mehrere Branches und beliebig viele Changesets. Jeder Branch enthält einen \gls{Pointer} (\gls{Head}) welcher auf das letzte in diesem \gls{Branch} erzeugte \gls{Changeset} zeigt. Die Changesets zeigen mittels eines Pointers auf das jeweilige Changeset welches zuvor erzeugt wurde. Durch diese listenartige Verkettung entsteht die History. Durch die Verschiebung des Heads besteht die Möglichkeit vorgenommene Änderungen wieder rückgängig zu machen. Jedes Changeset beinhaltet mindestens eine Modifikation. Eine Modifikation ist eine zusammenhängende Textpassage (durch die Offsets definiert) in einer Datei die geändert wurde. 

\newpage		
\subsection{Ausgewählte Zustandsdiagramme}

	Um das Verhalten eines Programms im laufenden Betrieb zu untersuchen, bedient man sich sogenannter \textbf{Zustandsdiagramme} \\
	Zustandsdiagramme bieten ein geeignetes Vokabular um das Ein- und Ausgabeverhalten eines Programms kompakt und präzise zu beschreiben.
	Da die Lebenszyklen der Objekte in Git komplex sind wurde hier ausgewählte Zustandsdiagramme dargestellt. \\

\underline{\textbf{\textsc{Push und Commit}}} \\
\includegraphics[width=\textwidth]{PuCo.jpg}\\\\
\textbf{Anmerkung:} Revert / Änderung wurden Rückgängig gemacht --> Pfeil von "Anzeige Änderung.." nach "Verzeichnis ist unverändert"\\\\
Die Möglichkeit zu commiten gibt es nur, wenn Änderungen vorliegen. Ansonsten wird eine Fehlermeldung ausgegeben, die den Nutzer darauf aufmerksam macht, dass es nichts zu commiten gibt.
Wurden Dateien oder Dokumente verändert, wird im SmartGit Fenster angezeigt, welche Dateien verändert wurden.\\
Der Nutzer hat in jedem Zustand die Möglichkeit, den Push-Button zu betätigen, allerdings mit unterschiedlichem Effekt:\\
Wurden die Änderungen noch nicht committed werden sie auch nicht auf den Server übertragen.
Es gibt nun den Fall, dass Änderungen vorgenommen und committed wurden, ohne das sie gepusht wurden.
Wenn der Nutzer nun weitere Änderung vornimmt, hat er die Möglichkeit die vorhergegangenen Änderungen auf den Server zu pushen, ohne dass die aktuellen Änderungen mit übernommen werden. 
\newpage	
\underline{\textbf{\textsc{Clone Repository}}}\\
\includegraphics[width=\textwidth]{Clone.jpg}\\\\
Zu Beginn eines Projektes kann der Anwender ein existierendes Repository zu seinem Projekt hinzufügen.
Dafür benötigt er die genau Web-Adresse eines bereits existierenden Repositorys. Diese wird dann vom System validiert. Bei Falscher Eingabe gibt es eine Fehlermeldung und der Nutzer gelangt zurück in das Abfragemenü.
Bei erfolgreicher Anmeldung wird das Repository lokal auf dem Computer gespeichert. \\\\
Alternative kann auch ein lokales leeres Repository initialisiert werden.\\
\underline{\textbf{\textsc{Pull}}}\\
\includegraphics[width=\textwidth]{Pull.jpg}\\\\
--> \textbf{Anmerkung:} "löse Konflikt" sollte " Konflikt gelöst" heißen.\\\\
Vom Nutzer gewählter Zeitpunkt" vielleicht besser "Pullstartvorgang"
Zu jedem vom Nutzer gewählten Zeitraum hat er die Möglichkeit, sein lokales Repository mit dem externen Repository abzugleichen. \\
Dafür wählt er die Option Pull, die alle seit dem letzten Abgleich veränderten Daten übernimmt.
Ein Konflikt tritt auf, wenn Änderungen an der gleichen Stelle vorgenommen wurden.
Der Nutzer muss dann den Konflikt lösen in dem er dem Programm sagt welche Änderung übernommen werden soll.

\newpage	
\underline{\textbf{\textsc{Merge}}}\\

Hallo Freunde, sollen wir es tun?

\underline{\textbf{\textsc{Branch}}}\\


\newpage	
%---Glossar als subsection und "Glossar" einfügen------------------------------------------
\setglossarysection{subsection}
\printglossary[title={Glossar}, numberedsection]

%------------------------------------------------------------------------------------------

\newpage		
\section{\underline{Erfahrung aus der Teamarbeit}}

	gemeinsam gewählter Prozess...
	(Gemeinsam)

\section{\underline{Schlussbetrachtung}}
	
	Zusammenfassend kann man sagen das hier noch nicht so viel passiert ist ;)	
	(Gemeinsam)
	
\end{document}

